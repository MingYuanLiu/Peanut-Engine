#pragma once
#include "runtime/core/reflection/reflection_core.h"
{{#include_headfiles}}
#include "{{headfile_name}}"
{{/include_headfiles}}

namespace peanut{
    {{#class_defines}}class {{class_name}};
    {{/class_defines}}
namespace reflection{
{{#class_defines}}namespace TypeReflectionOparator{
    class {{class_name}}Operators{
    public:
        static const char* GetClassName(){ return "{{class_name}}";}
        static void* ConstructFromJson(const Json& json_context){
            {{class_name}}* ret_instance= new {{class_name}};
            Serializer::Read(json_context, *ret_instance);
            return ret_instance;
        }
        static Json WriteByName(void* instance){
            return Serializer::Write(*({{class_name}}*)instance);
        }
        // base class
        static int Get{{class_name}}BaseClassReflectionInstanceList(ReflectionInstance* &out_list, void* instance){
            int count = {{class_base_class_size}};
            {{#class_has_base}}out_list = new ReflectionInstance[count];
            for (int i=0;i<count;++i){
            {{#class_base_class_defines}}
               out_list[i] = TypeMetaDefine({{class_base_class_name}},static_cast<{{class_name}}*>(instance));
            {{/class_base_class_defines}}
            }{{/class_has_base}}
            return count;
        }
        // fields
        {{#class_field_defines}}static const char* GetFieldName_{{class_field_name}}(){ return "{{class_field_name}}";}
        static const char* GetFieldTypeName_{{class_field_name}}(){ return "{{{class_field_type}}}";}
        static void Set_{{class_field_name}}(void* instance, void* field_value){ static_cast<{{class_name}}*>(instance)->{{class_field_name}} = *static_cast<{{{class_field_type}}}*>(field_value);}
        static void* Get_{{class_field_name}}(void* instance){ return static_cast<void*>(&(static_cast<{{class_name}}*>(instance)->{{class_field_name}}));}
        static bool IsArray_{{class_field_name}}(){ {{#class_field_is_vector}}return true;{{/class_field_is_vector}}{{^class_field_is_vector}}return false;{{/class_field_is_vector}} }
        {{/class_field_defines}}

        // methods
        {{#class_method_defines}}
        static const char* GetMethodName_{{class_method_name}}(){ return "{{class_method_name}}";}
        static void Invoke_{{class_method_name}}(void * instance){static_cast<{{class_name}}*>(instance)->{{class_method_name}}();}
        {{/class_method_defines}}
    };
}//namespace TypeReflectionOparator
{{#vector_exist}}namespace ArrayReflectionOperator{
{{#vector_defines}}#ifndef Array{{vector_useful_name}}OperatorMACRO
#define Array{{vector_useful_name}}OperatorMACRO
    class Array{{vector_useful_name}}Operators{
        public:
            static const char* GetArrayTypeName(){ return "{{{vector_type_name}}}";}
            static const char* GetElementTypeName(){ return "{{{vector_element_type_name}}}";}
            static int GetSize(void* instance){
                //todo: should check validation
                return static_cast<int>(static_cast<{{{vector_type_name}}}*>(instance)->size());
            }
            static void* Get(int index,void* instance){
                //todo: should check validation
                return static_cast<void*>(&((*static_cast<{{{vector_type_name}}}*>(instance))[index]));
            }
            static void Set(int index, void* instance, void* element_value){
                //todo: should check validation
                (*static_cast<{{{vector_type_name}}}*>(instance))[index] = *static_cast<{{{vector_element_type_name}}}*>(element_value);
            }
    };
#endif //Array{{vector_useful_name}}Operator
{{/vector_defines}}
}//namespace ArrayReflectionOperator{{/vector_exist}}

    void TypeWrapperRegister_{{class_name}}(){
        {{#class_field_defines}}
		FieldFunctions* field_function_tuple_{{class_field_name}}=new FieldFunctions(
            &TypeReflectionOparator::{{class_name}}Operators::Set_{{class_field_name}},
            &TypeReflectionOparator::{{class_name}}Operators::Get_{{class_field_name}},
            &TypeReflectionOparator::{{class_name}}Operators::GetClassName,
            &TypeReflectionOparator::{{class_name}}Operators::GetFieldName_{{class_field_name}},
            &TypeReflectionOparator::{{class_name}}Operators::GetFieldTypeName_{{class_field_name}},
            &TypeReflectionOparator::{{class_name}}Operators::IsArray_{{class_field_name}});
        REGISTER_FIELD_TO_MAP("{{class_name}}", field_function_tuple_{{class_field_name}});
        {{/class_field_defines}}

        {{#class_method_defines}}
        MethodFunctions* method_function_tuple_{{class_method_name}}=new MethodFunctions(
            &TypeReflectionOparator::{{class_name}}Operators::GetMethodName_{{class_method_name}},
            &TypeReflectionOparator::{{class_name}}Operators::Invoke_{{class_method_name}});
        REGISTER_METHOD_TO_MAP("{{class_name}}", method_function_tuple_{{class_method_name}});
        {{/class_method_defines}}
        
        {{#vector_exist}}
		{{#vector_defines}}
		ArrayFunctions* array_tuple_{{vector_useful_name}} = new  ArrayFunctions(
            &ArrayReflectionOperator::Array{{vector_useful_name}}Operators::Set,
            &ArrayReflectionOperator::Array{{vector_useful_name}}Operators::Get,
            &ArrayReflectionOperator::Array{{vector_useful_name}}Operators::GetSize,
            &ArrayReflectionOperator::Array{{vector_useful_name}}Operators::GetArrayTypeName,
            &ArrayReflectionOperator::Array{{vector_useful_name}}Operators::GetElementTypeName);
        REGISTER_ARRAY_TO_MAP("{{{vector_type_name}}}", array_tuple_{{vector_useful_name}});
        {{/vector_defines}}
		{{/vector_exist}}
		
        {{#class_need_register}}
		ClassFunctions* class_function_tuple_{{class_name}}=new ClassFunctions(
            &TypeReflectionOparator::{{class_name}}Operators::ConstructFromJson,
            &TypeReflectionOparator::{{class_name}}Operators::WriteByName,
			&TypeReflectionOparator::{{class_name}}Operators::Get{{class_name}}BaseClassReflectionInstanceList);
        REGISTER_BASE_CLASS_TO_MAP("{{class_name}}", class_function_tuple_{{class_name}});
        {{/class_need_register}}
    }{{/class_defines}}
namespace TypeWrappersRegister{
    void {{sourefile_name_upper_camel_case}}()
    {
        {{#class_defines}}TypeWrapperRegister_{{class_name}}();
    {{/class_defines}}
    }
}//namespace TypeWrappersRegister

}//namespace reflection
}//namespace peanut
